# 全局架构设计与模块目录

## 1. 项目概述
**EuNet** 是一个基于 C++20 的网络请求可视化工具。它不仅仅是一个 HTTP 客户端，更是一个**可观测的网络运行时环境**。

### 核心设计理念
1.  **可观测性优先 (Observability First)**：与传统网络库不同，该库的核心目标不是极致的吞吐量，而是**暴露网络过程中的每一个状态变化**（DNS解析、TCP握手、TLS握手、数据传输、状态流转）。
2.  **事件驱动架构 (Event-Driven Architecture)**：系统的核心是“事件总线”。底层的网络操作产生 `Event`，通过 `Orchestrator`（编排器）分发给 `Timeline`（存储）和 `Sink`（UI渲染）。
3.  **Rust 风格的错误处理**：通过 `Result<T, E>` 消除异常（Exception），强制显式处理错误，并提供语义丰富的错误分类（`util::Error`）。
4.  **RAII 与 资源管理**：通过 `Fd` 类和智能指针管理文件描述符与内存，防止资源泄漏。

## 2. 模块分层架构

系统自底向上分为五层：

| 层级 | 模块名称 | 职责描述 |
| :--- | :--- | :--- |
| **L5 (UI)** | `ui/` | **用户界面层**。基于 FTXUI 库，负责将核心层的事件快照渲染为终端图形界面。 |
| **L4 (App)** | `net/` | **应用协议层**。实现 HTTP、TCP Client 等具体协议逻辑，负责产生高层业务事件。 |
| **L3 (Core)** | `core/` | **核心逻辑层**。系统的“大脑”。负责事件聚合、生命周期状态机 (FSM)、时间线记录、线程调度。 |
| **L2 (HAL)** | `platform/` | **平台抽象层**。封装 OS 系统调用（Socket, Epoll, DNS, Time, Capability），屏蔽 Linux 底层细节。 |
| **L1 (Util)** | `util/` | **基础工具层**。提供通用的 Result 类型、错误处理机制、字节缓冲区等基础设施。 |

---

## 3. 详细模块目录设计文档

以下是各目录的职责摘要，稍后将展开每个文件的详细设计。

### 3.1 [`util/` (通用工具)](./design/util_design.md)
该模块不依赖任何业务逻辑，提供纯粹的 C++ 工具类。
*   **error.hpp/cpp**: 定义了统一的错误类型 `Error`，包含域（Domain）、类别（Category）和严重程度。
*   **result.hpp**: 实现了 `Result<T, E>` 模版，用于替代异常处理，提供类似 Rust 的链式调用（`map`, `and_then`）。
*   **byte_buffer.hpp/cpp**: 提供类似 Netty 的 `ByteBuffer`，支持自动扩容、读写指针管理。

### 3.2 [`platform/` (平台适配)](./design/platform_design.md)
该模块直接与 Linux Kernel 交互。
*   **fd.hpp/cpp**: 文件描述符的 RAII 封装，确保 `close` 被调用。
*   **poller.hpp/cpp**: `epoll` 的面向对象封装，处理 IO 多路复用。
*   **time.hpp/cpp**: 统一的时间处理，区分单调时间（计时）和墙上时间（显示）。
*   **capability.hpp/cpp**: Linux Capabilities 管理（如申请 `CAP_NET_RAW`）。
*   **net/**:
    *   **base_socket.hpp/cpp**: Socket 通用基类。
    *   **socket/tcp_socket.hpp**: TCP 特定实现。
    *   **socket/udp_socket.hpp**: UDP 特定实现。
    *   **endpoint.hpp**: IP 地址与端口封装。
    *   **dns_resolver.hpp**: 域名解析封装。

### 3.3 [`core/` (核心引擎)](./design/core_design.md)
该模块不涉及具体的 Socket API，只关心数据流和状态。
*   **event.hpp/cpp**: 定义系统中所有可能发生的事件结构。
*   **event_snapshot.hpp**: 用于 UI 渲染的事件不可变快照。
*   **lifecycle_fsm.hpp/cpp**: 能够根据事件流推导连接状态（Init -> Connecting -> Established...）的状态机。
*   **timeline.hpp/cpp**: 内存中的时序数据库，支持按 FD、时间、类型查询事件。
*   **orchestrator.hpp/cpp**: 核心控制器，连接 Timeline、FSM 和 UI Sink。
*   **engine.hpp**: 负责驱动 `Scenario` 运行的线程包装器。
*   **sink.hpp**: 事件消费者的接口定义。

### 3.4 [`net/` (网络实现)](./design/net_design.md)
该模块组合 Platform 和 Core，执行实际的网络任务。
*   **connection.hpp**: 连接抽象接口。
*   **connection/tcp_connection.hpp**: 组合了 `TCPSocket` 和 `ByteBuffer`。
*   **tcp_client.hpp/cpp**: 执行 TCP 连接流程，并向 Orchestrator 发送事件。
*   **http_client.hpp/cpp**: 基于 `TCPClient` 和 `Boost.Beast` 实现 HTTP 协议解析。
*   **http_scenario.hpp/cpp**: 定义具体的 HTTP 请求任务（URL解析、执行流程）。

### 3.5 [`tui/` (用户界面)](./design/tui_design.md)
*   **tui_app.hpp**: 定义 FTXUI 的布局、渲染循环和数据绑定。
*   **tui_sink.hpp**: 核心层到 UI 层的桥梁，处理线程安全的事件投递。

## 4. 应用开发的整体设计思路

### 4.1 应用定位与使用场景

EuNet 的定位并非传统意义上的高性能网络库或通用 HTTP 客户端工具，而是一个 **面向开发者的网络请求可视化与分析平台**。

在实际工程实践中，网络问题往往并不体现在“请求是否成功”，而体现在连接建立、协议交互、异常中断等细节过程上。

现有工具（如 curl、浏览器开发者工具或抓包软件）要么只暴露结果，要么与应用逻辑割裂，难以形成统一的分析视角。

因此，EuNet 的核心目标是：

* 将网络请求从“黑盒调用”转变为“可观察、可回溯的运行过程”；
* 为网络协议学习、调试分析和系统行为理解提供直观支撑；
* 在保证工程可扩展性的前提下，提供完整的运行时可视化能力。

### 4.2 总体架构设计思路

在整体设计上，EuNet 采用 **事件驱动 + 分层解耦** 的技术路线。所有底层网络操作均以事件的形式向上传递，而非通过同步调用或回调函数直接影响上层逻辑。该设计遵循以下原则：

1. **过程优先于结果**：系统关注的不只是请求是否成功，而是请求过程中发生的每一个状态变化。
2. **记录优先于展示**：所有事件首先被记录到时间线（Timeline）中，UI 只是其中的一种消费方式。
3. **核心逻辑与平台无关**：核心层不直接依赖 Socket 或系统调用，降低平台耦合度。

通过上述思路，EuNet 被设计为一个具备“网络运行时内核”特征的系统，而非简单的工具集合。

---

## 5. 关键模块的设计方案与实现重点

### 5.1 Orchestrator 与事件编排模型

Orchestrator 是 EuNet 的核心控制单元，负责连接网络执行层、状态机、时间线与 UI。所有来自网络层的事件都会被统一送入 Orchestrator，由其完成以下工作：

* 事件分发与调度；
* 生命周期状态机的驱动；
* 时间线记录；
* 向外部 Sink（如 TUI）广播不可变事件快照。

该设计避免了网络逻辑直接依赖 UI 或存储组件的问题，使系统具备良好的可扩展性。

### 5.2 生命周期 FSM 的设计

传统网络程序通常通过返回值或错误码判断连接状态，缺乏明确的状态语义。EuNet 引入生命周期有限状态机（FSM），通过事件流推导连接所处的逻辑阶段（如初始化、连接中、已建立、已关闭等）。

FSM 的优势在于：

* 将零散的事件归纳为高层语义状态；
* 便于 UI 层进行状态可视化；
* 为后续协议扩展（如 TLS）预留统一的状态演进模型。

### 5.3 Result / Error 错误处理体系

在错误处理方面，EuNet 明确放弃 C++ 异常机制，采用基于 `Result<T, E>` 的显式错误返回模型。所有错误均使用统一的 `Error` 类型描述，并包含错误域、类别与严重程度信息。

该设计的优势包括：

* 错误路径显式可见，避免隐式异常传播；
* 易于在事件模型中进行组合与传递；
* 提升系统在复杂网络场景下的可维护性与可调试性。

> 然而，这一机制的选取也是有范围的，对于无法恢复的内存分配异常（`std::bad_alloc`）等，仍然保留了 C++ 异常以显式展示异常的严重性。

### 5.4 ByteBuffer 的数据管理策略

EuNet 的 ByteBuffer 采用读写指针分离的设计，支持动态扩容与连续内存管理，能够高效配合 Socket 读写操作，并为上层协议解析提供稳定的数据视图。这一设计为后续引入零拷贝优化和多协议支持奠定了基础。

---

## 6. 创新点与技术特色分析

### 6.1 可观测性优先的网络客户端设计

与传统网络工具相比，EuNet 将“可观测性”作为首要设计目标。系统不仅返回请求结果，还完整暴露 DNS 解析、连接建立、数据传输及关闭等过程事件，从而显著提升网络行为的透明度。

### 6.2 基于时间线的事件记录模型

EuNet 使用 Timeline 作为事件的核心存储结构，所有事件均以不可变记录的形式保存。这种设计支持历史回溯、多视角分析，并为未来实现事件回放、导出和分析工具提供可能性。

### 6.3 工程化错误系统

相比于字符串错误或简单错误码，EuNet 的错误系统具备明确的分类与语义边界，能够在复杂系统中提供更高质量的诊断信息。

### 6.4 TUI 与网络内核的彻底解耦

通过 Sink 接口和事件快照机制，UI 层仅作为事件的消费者存在，不参与核心逻辑决策，保证了系统结构的清晰性和可维护性。

---

## 7. 功能测试与性能评测

### 7.1 功能测试

在功能测试阶段，主要覆盖以下场景：

| 测试场景       | 预期行为       | 测试结果 |
| ---------- | ---------- | ---- |
| 正常 HTTP 请求 | 完整事件流生成    | 通过   |
| DNS 解析失败   | 返回明确错误事件   | 通过   |
| TCP 连接失败   | FSM 状态正确回退 | 通过   |
| 服务端主动关闭    | 正确记录关闭事件   | 通过   |

测试结果表明，系统在常见网络场景下能够稳定运行，并生成完整、可追踪的事件序列。

### 7.2 性能测试与对比分析

性能测试选取 curl 及基于 Boost.Asio 的简易客户端作为对比对象，测试维度包括请求耗时与资源占用情况。

|库名|性能(req/s)|内存占用(MB)|
|---|----|--------|
|LibCurl|607.9|10.2|
|Boost.Beast|1054.9|10.4|
|Eunet|466.9|13.0|

测试结果显示：

* 在相同网络条件下，EuNet 的单次请求耗时略高于 curl；
* CPU 与内存开销略有增加，主要来源于事件记录与状态管理。

该结果符合系统的设计预期。EuNet 并非以极致性能为目标，而是在可接受的性能代价下，换取显著提升的可观测性与调试能力。在调试、分析和教学等场景中，该权衡具有明显优势。

---

## 8. 小结

通过上述设计与实现，EuNet 构建了一个具备工程完整性和扩展潜力的网络请求可视化系统。其架构设计与实现过程体现了对系统可维护性、可扩展性及可观测性的综合考量，具备进一步演进为通用网络分析平台的可能性。
